// crypto.xl - Криптографические функции подписи
import "SHA512.xl";

// Инициализация стандартного IV для SHA-512
func init_hash_state(h_ptr) {
    h_ptr[Int(0)] = 0x6a09e667f3bcc908;
    h_ptr[Int(1)] = 0xbb67ae8584caa73b;
    h_ptr[Int(2)] = 0x3c6ef372fe94f82b;
    h_ptr[Int(3)] = 0xa54ff53a5f1d36f1;
    h_ptr[Int(4)] = 0x510e527fade682d1;
    h_ptr[Int(5)] = 0x9b05688c2b3e6c1f;
    h_ptr[Int(6)] = 0x1f83d9abfb41bd6b;
    h_ptr[Int(7)] = 0x5be0cd19137e2179;
}

// Функция подписи блока данных секретным ключом
// Возвращает массив из 8 чисел (хеш-подпись)
func crypto_sign(data_ptr, data_len, secret_key) {
    init_sha_constants();

    // 1. Подготовка памяти
    var w = new(Int(80)); // Message schedule buffer
    var h = new(Int(8));  // Hash state

    init_hash_state(h);

    // 2. Формирование блока (Block Construction)
    // Очистка буфера w
    for(var i = Int(0); i < Int(80); i = i + Int(1)) {
        w[i] = Int(0);
    }

    // [0] -> Секретный ключ (соль)
    w[Int(0)] = secret_key;

    // Копирование данных (упрощенно: по одному слову на ячейку w)
    for(var j = Int(0); j < data_len; j = j + Int(1)) {
        if (j < Int(14)) {
            w[j + Int(1)] = data_ptr[j];
        }
    }

    // Паддинг и длина (упрощенная имитация SHA-512)
    w[Int(15)] = data_len * Int(64);

    // 3. Вызов основного алгоритма трансформации
    sha512_transform(h, w);

    // --- ВАЖНОЕ ИСПРАВЛЕНИЕ: Возвращаем указатель на массив хеша ---
    return h;
}